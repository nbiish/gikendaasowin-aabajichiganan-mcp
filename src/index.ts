#!/usr/bin/env node

/**
 * -----------------------------------------------------------------------------
 * Gikendaasowin Aabajichiganan - Core Cognitive Tools MCP Server (Simplified Core, Relaxed Validation)
 *
 * Description: Provides a streamlined suite of cognitive tools for an AI agent,
 *              enabling structured reasoning, planning, analysis, and iterative
 *              refinement, focusing on Chain of Thought and Chain of Draft.
 *              This server focuses on managing the AI's *internal cognitive loop*.
 *              External actions are planned within the 'think' step but executed
 *              by the calling environment. Validation on input content structure
 *              is removed. Tool results are returned as formatted Markdown.
 *              Refined Chain of Draft guidance. Versioning removed.
 *
 * Key Principles:
 * 1.  **Focused Deliberation:** Tools guide specific cognitive acts (assessing,
 *     thinking, reasoning via CoT, drafting via CoD).
 * 2.  **Centralized Analysis (`think`):** The `think` tool is mandatory after
 *     most cognitive actions or receiving external results, serving as the hub
 *     for comprehensive analysis, planning, reflection, synthesis, and confidence
 *     assessment. Structure is guided by the prompt, not enforced by the server.
 * 3.  **CUC-N Assessment:** Task characteristics determine the required depth
 *     of cognition (`think` vs. `quick_think` for initial step and simple results).
 * 4.  **Internal Generation First:** `chain_of_thought` and `chain_of_draft`
 *     log internal artifacts generated by the LLM.
 * 5.  **Iterative Refinement (CoT & CoD):** The `chain_of_thought` and
 *     `chain_of_draft` tools signal internal reasoning/drafting, prompting
 *     analysis via `think` or `quick_think`.
 * 6.  **Traceability:** All tool inputs are logged for a complete record.
 * 7.  **Markdown Output:** Tool results are formatted as Markdown for LLM consumption.
 *
 * Protocol:    Model Context Protocol (MCP) over stdio.
 * -----------------------------------------------------------------------------
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// --- Server Definition ---

const serverInfo = {
	name: "gikendaasowin-aabajichiganan-mcp",
	version: "0.9.16",
	description: `ᑭᑫᓐᑖᓱᐎᓐ ᐋᐸᒋᒋᑲᓇᓐ - Core Cognitive Tools Suite (Simplified, Relaxed Validation): Enables structured reasoning (CoT/CoD) and analysis for AI agents. Returns results as Markdown.`
};
const server = new McpServer(serverInfo);

// --- Logging Helpers ---

/**
 * Logs an incoming tool call to stderr.
 * @param toolName The name of the tool being called.
 * @param details Optional additional details about the call.
 */
function logToolCall(toolName: string, details?: string): void {
	const timestamp = new Date().toISOString();
	console.error(`[${timestamp}] [MCP Server] > Tool Call: ${toolName}${details ? ` - ${details}` : ''}`);
}

/**
 * Logs the result (success or failure) of a tool execution to stderr.
 * @param toolName The name of the tool executed.
 * @param success Whether the execution was successful.
 * @param resultDetails Optional details about the result.
 */
function logToolResult(toolName: string, success: boolean, resultDetails?: string): void {
	const timestamp = new Date().toISOString();
	console.error(`[${timestamp}] [MCP Server] < Tool Result: ${toolName} - ${success ? 'Success' : 'Failure'}${resultDetails ? ` - ${resultDetails}` : ''}`);
}

/**
 * Logs an error during tool execution and formats a standard error response for the LLM.
 * @param toolName The name of the tool where the error occurred.
 * @param error The error object or message.
 * @returns An McpToolResult containing the error message.
 */
function logToolError(toolName: string, error: unknown) {
	const timestamp = new Date().toISOString();
	const errorMessage = error instanceof Error ? error.message : String(error);
	console.error(`[${timestamp}] [MCP Server] ! Tool Error: ${toolName} - ${errorMessage}`);
	logToolResult(toolName, false, errorMessage); // Log failure result as well
	// Return a structured error message suitable for the LLM (still as plain text for clarity)
	return {
		content: [{
			type: "text" as const,
			text: `Error executing tool '${toolName}': ${errorMessage}. Please analyze this error.`
		}]
	};
}

// --- Core Cognitive Deliberation & Refinement Tools ---

/**
 * Tool: assess_cuc_n_mode
 * Purpose: Mandatory initial assessment of task characteristics to determine cognitive strategy.
 * Workflow: Call BEFORE starting complex tasks or significantly changing strategy.
 * Output: Returns the full assessment text formatted as Markdown.
 */
server.tool(
	"assess_cuc_n_mode",
	"**Mandatory Pre-Deliberation Assessment.** Evaluates task Complexity, Uncertainty, Consequence, Novelty (CUC-N) to determine required cognitive depth and initial strategy. MUST be called before starting complex tasks or changing strategy. Based on assessment, use either `think` (for structured analysis) or `quick_think` (for streamlined processing) in the next step.",
	{
		assessment_and_choice: z.string().describe("Your structured assessment including: 1) Situation Description, 2) CUC-N Ratings (Low/Medium/High for each), 3) Rationale for ratings, 4) Recommended Initial Cognitive Strategy (e.g., 'Start with chain_of_thought then think'), 5) Explicit Mode Selection ('Selected Mode: think' or 'Selected Mode: quick_think').")
	},
	async ({ assessment_and_choice }: { assessment_and_choice: string }) => {
		const toolName = 'assess_cuc_n_mode';
		logToolCall(toolName);
		try {
			// Basic Zod validation ensures it's a string. Content validation removed.
			const modeRegex = /Selected Mode: (think|quick_think)/i;
			const modeMatch = assessment_and_choice.match(modeRegex);
			const selectedMode = modeMatch ? modeMatch[1].toLowerCase() : "unknown"; // Extract mode for logging

			logToolResult(toolName, true, `Selected mode (extracted): ${selectedMode}`);
			// Log full input for traceability
			console.error(`[${new Date().toISOString()}] [MCP Server] - ${toolName} Input:\n${assessment_and_choice}`);

			// Return the full assessment text formatted as Markdown
			return {
				content: [{
					type: "text" as const,
					text: "```markdown\n" + assessment_and_choice + "\n```"
				}]
			};
		} catch (error: unknown) {
			return logToolError(toolName, error);
		}
	}
);

/**
 * Tool: think
 * Purpose: The **CENTRAL, COMPREHENSIVE HUB** for the cognitive loop. Incorporates OODReAct principles.
 * Workflow: Handles all complex analysis, planning, reflection, synthesis, and confidence assessment. Structure is guided by the prompt.
 * Output: Returns the structured thought text itself, formatted as Markdown.
 */
server.tool(
	"think",
	"**MANDATORY Central Hub for Comprehensive Analysis and Planning.** Called after assessment (`assess_cuc_n_mode`), after `chain_of_thought` or `chain_of_draft` results, or after external action results/errors. Incorporates OODReAct principles (Observe-Orient-Decide-Reason-Act) for enhanced problem-solving. This is where you perform ALL detailed analysis, planning (including multi-step strategies), reflection, synthesis, and confidence assessment. Structure your thought clearly using headings. For simpler follow-up steps, consider using `quick_think` instead.",
	{
		thought: z.string().describe("Your **detailed** internal monologue covering Analysis/Observation, Plan/Decision, Verification, Risk & Contingency, and Learning & Adaptation. Use clear headings. OODReAct-style headers are recommended.")
	},
	async ({ thought }: { thought: string }) => {
		const toolName = 'think';
		logToolCall(toolName);

		try {
			// Basic Zod validation ensures it's a non-empty string. Content validation removed.
			if (thought.trim().length === 0) {
				throw new Error('Invalid thought: Must be a non-empty string containing substantive reasoning.');
			}

			logToolResult(toolName, true, `Thought logged (length: ${thought.length})`);
			// Log full input for traceability
			console.error(`[${new Date().toISOString()}] [MCP Server] - ${toolName} Input:\n${thought}`);

			// Returns the same thought text received, formatted as Markdown.
			return {
				content: [{
					type: "text" as const,
					text: "```markdown\n" + thought + "\n```"
				}]
			};
		} catch (error: unknown) {
			// Use logToolError to format the error for the LLM
			return logToolError(toolName, error);
		}
	}
);

/**
 * Cognitive Checkpoint ONLY for situations explicitly assessed as strictly Low CUC-N
 * (via `assess_cuc_n_mode`) or for trivial confirmations/acknowledgements where
 * detailed analysis via `think` is unnecessary. Use SPARINGLY.
 */
export interface QuickThinkInput {
	/**
	 * Your **concise** thought or confirmation for this simple, low CUC-N step.
	 * Briefly state the observation/action and confirm it's trivial.
	 */
	brief_thought: string;
}

/**
 * Tool: quick_think
 * Purpose: A lightweight cognitive checkpoint for streamlined processing and simple confirmations.
 * Workflow: Use when full structured analysis via `think` is not necessary.
 * Output: Returns the brief thought text, formatted as Markdown.
 */
server.tool(
	"quick_think",
	"Cognitive Checkpoint for streamlined processing and simple confirmations where detailed analysis via `think` is unnecessary. Use when full structured deliberation would be excessive for the current step.",
	{
		brief_thought: z.string().describe("Your **concise** thought or confirmation for this step. Briefly state the observation/action and explain why detailed analysis isn't needed.")
	},
	async ({ brief_thought }: { brief_thought: string }) => {
		const toolName = 'quick_think';
		logToolCall(toolName);
		try {
			// Basic Zod validation ensures it's a non-empty string. Content validation removed.
			if (brief_thought.trim().length === 0) {
				throw new Error('Invalid brief_thought: Must be a non-empty string.');
			}
			logToolResult(toolName, true, `Logged: ${brief_thought.substring(0, 80)}...`);
			// Log full input for traceability
			console.error(`[${new Date().toISOString()}] [MCP Server] - ${toolName} Input:\n${brief_thought}`);

			// Return the brief thought text, formatted as Markdown
			return {
				content: [{
					type: "text" as const,
					text: "```markdown\n" + brief_thought + "\n```"
				}]
			};
		} catch (error: unknown) {
			return logToolError(toolName, error);
		}
	}
);

/**
 * Tool: chain_of_thought
 * Purpose: Guides *internal generation* and logging of detailed, step-by-step reasoning draft (CoT).
 * Workflow: Generate CoT -> Call this tool with CoT text -> Follow with either `think` or `quick_think`.
 * Output: Returns the CoT text formatted as Markdown.
 */
server.tool(
	"chain_of_thought",
	"Guides *internal generation* and logging of **detailed, step-by-step reasoning draft (CoT)**. Call this tool *with* the generated CoT text you created internally. Returns the CoT text formatted as Markdown. Follow with either `think` (for complex reasoning chains requiring detailed analysis) or `quick_think` (for straightforward reasoning steps) to process the CoT and plan next actions.",
	{
		generated_cot_text: z.string().describe("The **full, step-by-step Chain of Thought draft** you generated internally to solve or analyze the problem."),
		problem_statement: z.string().describe("The original problem statement or question this CoT addresses.")
	},
	async ({ generated_cot_text, problem_statement }: { generated_cot_text: string, problem_statement: string }) => {
		const toolName = 'chain_of_thought';
		logToolCall(toolName);
		try {
			// Basic Zod validation ensures non-empty strings. Content validation removed.
			if (generated_cot_text.trim().length === 0) {
				throw new Error('Invalid generated_cot_text: Must be a non-empty string containing the CoT.');
			}
			if (problem_statement.trim().length === 0) {
				throw new Error('Invalid problem_statement: Must provide the original problem.');
			}

			logToolResult(toolName, true, `Problem: ${problem_statement.substring(0, 50)}...`);
			// Log full input for traceability
			console.error(`[${new Date().toISOString()}] [MCP Server] - ${toolName} Input:\nProblem: ${problem_statement}\nReasoning:\n${generated_cot_text}`);

			// Return the CoT text, formatted as Markdown
			return {
				content: [{
					type: "text" as const,
					text: "```markdown\n" + generated_cot_text + "\n```"
				}]
			};
		} catch (error: unknown) {
			return logToolError(toolName, error);
		}
	}
);

/**
 * Tool: chain_of_draft
 * Purpose: Signals that internal drafts have been generated/refined using Chain of Draft (CoD) principles for efficient, concise reasoning.
 * Workflow: Internally generate/refine concise draft(s) following CoD guidelines -> Call this tool with a description -> Follow with either `think` or `quick_think`.
 * Output: Returns the draft description formatted as Markdown.
 */
server.tool(
	"chain_of_draft",
	"Signals that one or more **internal drafts** have been generated/refined using **Chain of Draft (CoD)** principles. CoD aims for **maximum efficiency** by mimicking human note-taking, focusing on minimal token usage while preserving reasoning quality. Use this *instead of* detailed Chain of Thought when speed and token economy are important, or when the reasoning involves calculations or symbolic manipulation.\n\n**How to Construct SOTA CoD Internally:**\n1.  **Extreme Conciseness:** Each reasoning step or draft element should be extremely brief (e.g., often just 1-5 words, like a quick note). AVOID full sentences.\n2.  **Symbols & Equations:** Prioritize mathematical notation (e.g., `x = 5*y`, `area = l*w`), code snippets (e.g., `user.id`, `config['key']`), or recognized symbols over descriptive text.\n3.  **Essential Information Only:** Capture only the absolute minimum information needed to proceed. Omit explanations, justifications, or restatements of the problem unless strictly necessary for the next step.\n4.  **Structure:** Can be a sequence of short phrases, key values, equations, or code elements, often line-by-line. Think 'scratchpad' not 'essay'.\n5.  **Contrast with CoT:** Unlike CoT's verbose explanations, CoD focuses purely on the *result* or *key element* of each reasoning step.\n6.  **Final Answer (Optional but Recommended):** If the CoD sequence leads directly to a final answer, clearly mark it at the end, often using `#### Final Answer: [answer]`.\n\nCall this tool *after* generating/refining draft(s) internally following these guidelines. Provide a brief description of the draft's purpose. Returns the description formatted as Markdown. Follow with either `think` (for complex drafts requiring detailed analysis) or `quick_think` (for straightforward drafts) to evaluate and plan next steps.",
	{
		draft_description: z.string().describe("Brief but specific description of the CoD draft(s) generated/refined internally (e.g., 'Calculated intermediate values x, y', 'API call structure draft', 'Error handling logic sketch', 'Key parameters extracted').")
	},
	async ({ draft_description }: { draft_description: string }) => {
		const toolName = 'chain_of_draft';
		logToolCall(toolName, `Description: ${draft_description}`);
		try {
			// Basic Zod validation ensures non-empty string. Content validation removed.
			if (draft_description.trim().length === 0) {
				throw new Error('Invalid draft_description: Must provide a description.');
			}

			logToolResult(toolName, true);
			// Log full input for traceability
			console.error(`[${new Date().toISOString()}] [MCP Server] - ${toolName} Input:\nDescription: ${draft_description}`);

			// Return the draft description, formatted as Markdown
			return {
				content: [{
					type: "text" as const,
					text: "```markdown\n" + draft_description + "\n```"
				}]
			};
		} catch (error: unknown) {
			return logToolError(toolName, error);
		}
	}
);


// --- Server Lifecycle and Error Handling ---

/**
 * Gracefully shuts down the server.
 */
async function shutdown(): Promise<void> {
	console.error('\n[MCP Server] Shutting down gracefully...');
	try {
		await server.close();
		console.error('[MCP Server] Server closed.');
		process.exit(0);
	} catch (err) {
		console.error('[MCP Server] Error during shutdown:', err);
		process.exit(1);
	}
}

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);

process.on('uncaughtException', (error, origin) => {
	const timestamp = new Date().toISOString();
	console.error(`[${timestamp}] [MCP Server] FATAL: Uncaught Exception at: ${origin}`, error);
	// Attempt graceful shutdown, but exit quickly if it fails
	shutdown().catch(() => process.exit(1));
});

process.on('unhandledRejection', (reason, promise) => {
	const timestamp = new Date().toISOString();
	console.error(`[${timestamp}] [MCP Server] FATAL: Unhandled Promise Rejection:`, reason);
	// Attempt graceful shutdown, but exit quickly if it fails
	shutdown().catch(() => process.exit(1));
});

// --- Start the Server ---

/**
 * Initializes and starts the MCP server.
 */
async function main(): Promise<void> {
	try {
		const transport = new StdioServerTransport();
		await server.connect(transport);
		const border = '-----------------------------------------------------';
		console.error(border);
		console.error(` ${serverInfo.description}`);
		// Version logging removed from startup message
		console.error(' Status: Running on stdio, awaiting MCP requests...');
		console.error(border);
	}
	catch (error) {
		const timestamp = new Date().toISOString();
		console.error(`[${timestamp}] [MCP Server] Fatal error during startup:`, error);
		process.exit(1);
	}
}

// Execute the main function to start the server
main();