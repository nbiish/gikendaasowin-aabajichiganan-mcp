#!/usr/bin/env node
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create the MCP server
const server = new McpServer({
	name: "gikendaasowin-aabajichiganan-mcp",
	version: "0.3.8",
	description: "ᑭᑫᓐᑖᓱᐎᓐ ᐋᐸᒋᒋᑲᓇᓐ - Gikendaasowin Aabajichiganan - (Cognitive Tools): Provides a suite of advanced cognitive reasoning tools for sophisticated problem-solving"
});

// Define the think tool
server.tool(
	"think",
	"Your primary cognitive workspace for structured analysis and planning. This tool provides a deliberate pause for thorough consideration before taking action. Use it to deconstruct problems, evaluate options, verify compliance, and refine understanding. MANDATORY before finalizing responses or after using other cognitive tools.",
	{
		thought: z.string().describe("Your primary cognitive workspace, acting like the 'Navigator' in pair programming. MANDATORY before final responses/actions and after using other cognitive tools. Use to: 1) Analyze tool outputs & user requests, 2) Verify plans against constraints/policies, 3) Plan next steps, 4) Resolve ambiguities, 5) Self-correct reasoning. Ensures structured, compliant, and well-reasoned actions. Quality of reasoning is key; structure helps clarity.")
	},
	async ({ thought }) => {
		if (!thought || typeof thought !== 'string') {
			throw new Error('Invalid thought: Must be a non-empty string');
		}

		return {
			content: [{
				type: "text" as const,
				text: thought
			}]
		};
	}
);

// Define the chain_of_thought tool
server.tool(
	"chain_of_thought",
	"Generates explicit, sequential reasoning steps for complex problem-solving. This tool breaks down a problem into a detailed, linear sequence of logical deductions. Ideal for tasks requiring high explainability. Output MUST be analyzed using the 'think' tool.",
	{
		problem_statement: z.string().describe("Generates a detailed, step-by-step logical deduction path for a specific problem. Emulates a thorough 'walkthrough'. Output MUST be analyzed and integrated using the 'think' tool before taking further action.")
	},
	async ({ problem_statement }) => {
		if (!problem_statement || typeof problem_statement !== 'string') {
			throw new Error('Invalid problem statement: Must be a non-empty string');
		}

		return {
			content: [{
				type: "text" as const,
				text: problem_statement
			}]
		};
	}
);

// Define the reflection tool
server.tool(
	"reflection",
	"Facilitates self-critique and iterative improvement of reasoning or plans. This tool evaluates logical consistency, completeness, and potential biases, then suggests specific refinements. Use its output within a subsequent 'think' step.",
	{
		input_reasoning_or_plan: z.string().describe("Performs self-critique on reasoning or plans generated by 'think' or other tools. Identifies flaws, biases, or inconsistencies. Use its output within a subsequent 'think' step to refine your approach.")
	},
	async ({ input_reasoning_or_plan }) => {
		if (!input_reasoning_or_plan || typeof input_reasoning_or_plan !== 'string') {
			throw new Error('Invalid input: Must be a non-empty string');
		}

		return {
			content: [{
				type: "text" as const,
				text: input_reasoning_or_plan
			}]
		};
	}
);

// Define the plan_and_solve tool
server.tool(
	"plan_and_solve",
	"Develops a high-level, structured strategy for complex, multi-stage objectives. This tool outlines major phases required to achieve a goal, identifying which approaches might be needed at each stage. The generated plan MUST be reviewed within the 'think' tool.",
	{
		task_objective: z.string().describe("Develops a high-level, multi-step strategy for complex objectives. Outlines major phases and potential tool usage per phase. The generated plan MUST be reviewed, validated, and managed via the 'think' tool.")
	},
	async ({ task_objective }) => {
		if (!task_objective || typeof task_objective !== 'string') {
			throw new Error('Invalid task objective: Must be a non-empty string');
		}

		return {
			content: [{
				type: "text" as const,
				text: task_objective
			}]
		};
	}
);

// Define the chain_of_draft tool
server.tool(
	"chain_of_draft",
	"Generates concise, iterative drafts of reasoning steps, prioritizing efficiency over exhaustive detail. This tool produces brief, essential intermediate thoughts, allowing for rapid exploration without the verbosity of full chain-of-thought. Output MUST be analyzed via the 'think' tool.",
	{
		problem_statement: z.string().describe("Generates concise, iterative reasoning drafts for rapid exploration when full CoT verbosity isn't needed. Ideal for quick brainstorming or outlining. Output drafts MUST be analyzed via the 'think' tool.")
	},
	async ({ problem_statement }) => {
		if (!problem_statement || typeof problem_statement !== 'string') {
			throw new Error('Invalid problem statement: Must be a non-empty string');
		}

		return {
			content: [{
				type: "text" as const,
				text: problem_statement
			}]
		};
	}
);

// Setup error handling
process.on('SIGINT', async () => {
	console.error('[CognitiveToolsServer] Received SIGINT, shutting down.');
	await server.close();
	process.exit(0);
});

process.on('SIGTERM', async () => {
	console.error('[CognitiveToolsServer] Received SIGTERM, shutting down.');
	await server.close();
	process.exit(0);
});

process.on('uncaughtException', (error) => {
	console.error('[CognitiveToolsServer] Uncaught exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
	console.error('[CognitiveToolsServer] Unhandled promise rejection:', reason);
});

// Start the server
async function main() {
	try {
		const transport = new StdioServerTransport();
		await server.connect(transport);
		console.error('ᑭᑫᓐᑖᓱᐎᓐ ᐋᐸᒋᒋᑲᓇᓐ - Gikendaasowin Aabajichiganan - (Cognitive Tools) MCP Server running on stdio');
	} catch (error) {
		console.error('Fatal error in main():', error);
		process.exit(1);
	}
}

main();
